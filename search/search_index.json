{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00cdndice del proyecto Autor: Adrian Mu\u00f1oz Garcia Fecha: (a\u00f1adir fecha) Elementos de Python Ejecuci\u00f3n y Depuraci\u00f3n Pruebas Ejecuci\u00f3n en Sandbox Reflexi\u00f3n Elementos de Python Enlace para ver el c\u00f3digo comentado con Markdown: C\u00f3digo comentado: lavadero_documentado_Adrian.md C\u00f3digo comentado: Main_app_documentado_Adrian.md Ejecuci\u00f3n y Depuraci\u00f3n El contenido completo est\u00e1 en: - Ejecuci\u00f3n_y_Depuraci\u00f3n.md Pruebas El contenido completo est\u00e1 en: - Pruebas.md Ejecuci\u00f3n en Sandbox El contenido completo est\u00e1 en: - Ejecuci\u00f3n_en_Sandbox.md Reflexi\u00f3n El contenido completo est\u00e1 en: - Reflexi\u00f3n.md","title":"Inicio"},{"location":"#indice-del-proyecto","text":"Autor: Adrian Mu\u00f1oz Garcia Fecha: (a\u00f1adir fecha) Elementos de Python Ejecuci\u00f3n y Depuraci\u00f3n Pruebas Ejecuci\u00f3n en Sandbox Reflexi\u00f3n","title":"\u00cdndice del proyecto"},{"location":"#elementos-de-python","text":"Enlace para ver el c\u00f3digo comentado con Markdown: C\u00f3digo comentado: lavadero_documentado_Adrian.md C\u00f3digo comentado: Main_app_documentado_Adrian.md","title":"Elementos de Python"},{"location":"#ejecucion-y-depuracion","text":"El contenido completo est\u00e1 en: - Ejecuci\u00f3n_y_Depuraci\u00f3n.md","title":"Ejecuci\u00f3n y Depuraci\u00f3n"},{"location":"#pruebas","text":"El contenido completo est\u00e1 en: - Pruebas.md","title":"Pruebas"},{"location":"#ejecucion-en-sandbox","text":"El contenido completo est\u00e1 en: - Ejecuci\u00f3n_en_Sandbox.md","title":"Ejecuci\u00f3n en Sandbox"},{"location":"#reflexion","text":"El contenido completo est\u00e1 en: - Reflexi\u00f3n.md","title":"Reflexi\u00f3n"},{"location":"Ejecucion_en_Sandbox/","text":"Ejecuci\u00f3n en Sandbox Para validar el comportamiento del programa en un entorno controlado, se ha realizado la ejecuci\u00f3n dentro de una Sandbox (m\u00e1quina virtual aislada con Kali Linux). Esto permite simular el uso real del sistema sin afectar el entorno principal y garantiza que el c\u00f3digo funciona correctamente en condiciones reproducibles. \ud83d\udd27 Proceso realizado Se accede a la m\u00e1quina virtual. Se abre una terminal y se navega al directorio del proyecto. Activamos el entorno con el siguiente comando: source .venv/bin/activate Se ejecuta el archivo main_app.py con el siguiente comando: firejail python src/main_app.py El programa simula distintos escenarios de lavado, mostrando por consola: Opciones seleccionadas. Transici\u00f3n por fases. Estado final del lavadero. Ingresos acumulados. \ud83d\udcf8 Capturas del proceso Terminal dentro de la Sandbox mostrando la ejecuci\u00f3n del script. Esta ejecuci\u00f3n confirma que el sistema funciona correctamente en un entorno aislado, y que los resultados obtenidos coinciden con los esperados seg\u00fan los requisitos funcionales.","title":"Ejecuci\u00f3n en Sandbox"},{"location":"Ejecucion_en_Sandbox/#ejecucion-en-sandbox","text":"Para validar el comportamiento del programa en un entorno controlado, se ha realizado la ejecuci\u00f3n dentro de una Sandbox (m\u00e1quina virtual aislada con Kali Linux). Esto permite simular el uso real del sistema sin afectar el entorno principal y garantiza que el c\u00f3digo funciona correctamente en condiciones reproducibles.","title":"Ejecuci\u00f3n en Sandbox"},{"location":"Ejecucion_en_Sandbox/#proceso-realizado","text":"Se accede a la m\u00e1quina virtual. Se abre una terminal y se navega al directorio del proyecto. Activamos el entorno con el siguiente comando: source .venv/bin/activate Se ejecuta el archivo main_app.py con el siguiente comando: firejail python src/main_app.py El programa simula distintos escenarios de lavado, mostrando por consola: Opciones seleccionadas. Transici\u00f3n por fases. Estado final del lavadero. Ingresos acumulados.","title":"\ud83d\udd27 Proceso realizado"},{"location":"Ejecucion_en_Sandbox/#capturas-del-proceso","text":"Terminal dentro de la Sandbox mostrando la ejecuci\u00f3n del script. Esta ejecuci\u00f3n confirma que el sistema funciona correctamente en un entorno aislado, y que los resultados obtenidos coinciden con los esperados seg\u00fan los requisitos funcionales.","title":"\ud83d\udcf8 Capturas del proceso"},{"location":"Ejecucion_y_Depuracion/","text":"Ejecuci\u00f3n y Depuraci\u00f3n de la Aplicaci\u00f3n En esta secci\u00f3n se documenta el proceso de ejecuci\u00f3n inicial, identificaci\u00f3n del error, correcci\u00f3n del c\u00f3digo y verificaci\u00f3n final del funcionamiento correcto. Se incluyen capturas de pantalla completas donde se observa el terminal con mi nombre de usuario y/o imagen de la plataforma Moodle, tal como se exige en la pr\u00e1ctica. 1. Ejecuci\u00f3n inicial con error Al ejecutar por primera vez el script proporcionado, se produce un error que impide el funcionamiento correcto de la aplicaci\u00f3n. Descripci\u00f3n del error: El error se debe a que se intenta aplicar la opci\u00f3n de encerado sin haber activado el secado a mano, lo cual viola una condici\u00f3n l\u00f3gica del programa. El sistema lanza una excepci\u00f3n ValueError indicando que no se puede encerar el coche sin haberlo secado a mano previamente. 2. Correcci\u00f3n del c\u00f3digo Tras analizar el error, se procede a modificar el c\u00f3digo fuente para cumplir con la l\u00f3gica requerida por la aplicaci\u00f3n. Explicaci\u00f3n de la soluci\u00f3n: Se ha ajustado la funci\u00f3n ejecutarSimulacion() para que valide correctamente las combinaciones de opciones. En concreto, se ha a\u00f1adido una condici\u00f3n que impide seleccionar encerado=True si secado_mano=False , lanzando un mensaje de error claro para el usuario. 3. Ejecuci\u00f3n final sin errores Una vez corregido el c\u00f3digo, se vuelve a ejecutar la aplicaci\u00f3n para verificar que el error ha sido solucionado y que el programa funciona correctamente. Resultado: La aplicaci\u00f3n se ejecuta correctamente, procesando las fases del lavado sin lanzar errores. Se muestra el avance por fases y el incremento de ingresos acumulados, confirmando que la l\u00f3gica del programa ahora es coherente y funcional. Conclusi\u00f3n Este proceso ha permitido identificar una incoherencia en la l\u00f3gica de negocio del programa, aplicar una soluci\u00f3n efectiva y verificar su funcionamiento mediante pruebas. La documentaci\u00f3n visual y explicativa garantiza la trazabilidad del error y su resoluci\u00f3n.","title":"Ejecuci\u00f3n y Depuraci\u00f3n de la Aplicaci\u00f3n"},{"location":"Ejecucion_y_Depuracion/#ejecucion-y-depuracion-de-la-aplicacion","text":"En esta secci\u00f3n se documenta el proceso de ejecuci\u00f3n inicial, identificaci\u00f3n del error, correcci\u00f3n del c\u00f3digo y verificaci\u00f3n final del funcionamiento correcto. Se incluyen capturas de pantalla completas donde se observa el terminal con mi nombre de usuario y/o imagen de la plataforma Moodle, tal como se exige en la pr\u00e1ctica.","title":"Ejecuci\u00f3n y Depuraci\u00f3n de la Aplicaci\u00f3n"},{"location":"Ejecucion_y_Depuracion/#1-ejecucion-inicial-con-error","text":"Al ejecutar por primera vez el script proporcionado, se produce un error que impide el funcionamiento correcto de la aplicaci\u00f3n. Descripci\u00f3n del error: El error se debe a que se intenta aplicar la opci\u00f3n de encerado sin haber activado el secado a mano, lo cual viola una condici\u00f3n l\u00f3gica del programa. El sistema lanza una excepci\u00f3n ValueError indicando que no se puede encerar el coche sin haberlo secado a mano previamente.","title":"1. Ejecuci\u00f3n inicial con error"},{"location":"Ejecucion_y_Depuracion/#2-correccion-del-codigo","text":"Tras analizar el error, se procede a modificar el c\u00f3digo fuente para cumplir con la l\u00f3gica requerida por la aplicaci\u00f3n. Explicaci\u00f3n de la soluci\u00f3n: Se ha ajustado la funci\u00f3n ejecutarSimulacion() para que valide correctamente las combinaciones de opciones. En concreto, se ha a\u00f1adido una condici\u00f3n que impide seleccionar encerado=True si secado_mano=False , lanzando un mensaje de error claro para el usuario.","title":"2. Correcci\u00f3n del c\u00f3digo"},{"location":"Ejecucion_y_Depuracion/#3-ejecucion-final-sin-errores","text":"Una vez corregido el c\u00f3digo, se vuelve a ejecutar la aplicaci\u00f3n para verificar que el error ha sido solucionado y que el programa funciona correctamente. Resultado: La aplicaci\u00f3n se ejecuta correctamente, procesando las fases del lavado sin lanzar errores. Se muestra el avance por fases y el incremento de ingresos acumulados, confirmando que la l\u00f3gica del programa ahora es coherente y funcional.","title":"3. Ejecuci\u00f3n final sin errores"},{"location":"Ejecucion_y_Depuracion/#conclusion","text":"Este proceso ha permitido identificar una incoherencia en la l\u00f3gica de negocio del programa, aplicar una soluci\u00f3n efectiva y verificar su funcionamiento mediante pruebas. La documentaci\u00f3n visual y explicativa garantiza la trazabilidad del error y su resoluci\u00f3n.","title":"Conclusi\u00f3n"},{"location":"Elementos_de_Python/","text":"","title":"Elementos de Python"},{"location":"Main_app_documentado_Adrian/","text":"Bloque 1: Importaci\u00f3n from lavadero import Lavadero: Importa la clase Lavadero definida en el archivo lavadero.py . Funci\u00f3n: Permite usar en este script todas las operaciones y atributos del lavadero. Nota: En Python, la importaci\u00f3n busca el archivo en el mismo directorio o en el PYTHONPATH . # main_app.py from lavadero import Lavadero Bloque 2: Definici\u00f3n de la funci\u00f3n ejecutarSimulacion Prop\u00f3sito: Simular un ciclo de lavado con las opciones dadas. Par\u00e1metros: lavadero : instancia de la clase Lavadero. prelavado : booleano, indica si se solicita prelavado a mano. secado_mano : booleano, indica si se solicita secado a mano. encerado : booleano, indica si se solicita encerado. Flujo de ejecuci\u00f3n: Imprime las opciones seleccionadas. Llama a hacerLavado() para iniciar el ciclo. Imprime el estado inicial del lavadero. Avanza fase por fase en un bucle controlado por contador (m\u00e1x. 20 pasos). Imprime cada fase recorrida. Al finalizar, muestra el estado final y los ingresos acumulados. Manejo de excepciones: ValueError : si se intenta encerar sin secado a mano. RuntimeError : si se intenta iniciar un lavado estando ocupado. Exception : cualquier otro error inesperado. def ejecutarSimulacion(lavadero, prelavado, secado_mano, encerado): \"\"\" Simula el proceso de lavado para un veh\u00edculo con las opciones dadas. Ahora acepta una instancia de lavadero. \"\"\" print(\"--- INICIO: Prueba de Lavado con Opciones Personalizadas ---\") print(f\"Opciones solicitadas: [Prelavado: {prelavado}, Secado a mano: {secado_mano}, Encerado: {encerado}]\") try: lavadero.hacerLavado(prelavado, secado_mano, encerado) print(\"\\nCoche entra. Estado inicial:\") lavadero.imprimir_estado() print(\"\\nAVANZANDO FASE POR FASE:\") pasos = 0 while lavadero.ocupado and pasos < 20: lavadero.avanzarFase() print(f\"-> Fase actual: \", end=\"\") lavadero.imprimir_fase() print() pasos += 1 print(\"\\n----------------------------------------\") print(\"Lavado completo. Estado final:\") lavadero.imprimir_estado() print(f\"Ingresos acumulados: {lavadero.ingresos:.2f} \u20ac\") print(\"----------------------------------------\") except ValueError as e: # Captura la excepci\u00f3n de regla de negocio (Requisito 2) print(f\"ERROR DE ARGUMENTO: {e}\") except RuntimeError as e: # Captura la excepci\u00f3n de estado (Requisito 3) print(f\"ERROR DE ESTADO: {e}\") except Exception as e: print(f\"ERROR INESPERADO: {e}\") Bloque 3: Punto de entrada (main) con ejemplos if name == \" main \": Garantiza que el bloque se ejecute solo si el archivo se ejecuta directamente, no cuando se importa como m\u00f3dulo. lavadero_global = Lavadero(): Se crea una \u00fanica instancia de Lavadero para acumular ingresos entre simulaciones. Ejemplos de ejecuci\u00f3n: Ejemplo 1: Prelavado + Secado a mano + Encerado \u2192 ingresos esperados 8.70 \u20ac. Ejemplo 2: Sin extras \u2192 ingresos esperados 5.00 \u20ac. Ejemplo 3: Encerado sin secado \u2192 debe lanzar ValueError . Ejemplo 4: Solo prelavado \u2192 ingresos esperados 6.50 \u20ac. Funci\u00f3n: Demostrar distintos casos de uso, validar reglas de negocio y mostrar acumulaci\u00f3n de ingresos. if __name__ == \"__main__\": lavadero_global = Lavadero() # Usamos una \u00fanica instancia para acumular ingresos # EJEMPLO 1: Lavado completo con prelavado, secado a mano, con encerado (Requisito 8 y 14) # Precio esperado: 5.00 + 1.50 + 1.00 + 1.20 = 8.70 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 1: Prelavado (S), Secado a mano (S), Encerado (S)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=True, encerado=True) # EJEMPLO 2: Lavado r\u00e1pido sin extras (Requisito 9) # Precio esperado: 5.00 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 2: Sin extras (Prelavado: N, Secado a mano: N, Encerado: N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=False) # EJEMPLO 3: Lavado con encerado, pero sin secado a mano (Debe lanzar ValueError - Requisito 2) print(\"\\n=======================================================\") print(\"EJEMPLO 3: ERROR (Encerado S, Secado a mano N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=True) # EJEMPLO 4: Lavado con prelavado a mano (Requisito 4 y 10) # Precio esperado: 5.00 + 1.50 = 6.50 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False) ======================================================= EJEMPLO 1: Prelavado (S), Secado a mano (S), Encerado (S) --- INICIO: Prueba de Lavado con Opciones Personalizadas --- Opciones solicitadas: [Prelavado: True, Secado a mano: True, Encerado: True] Coche entra. Estado inicial: ---------------------------------------- Ingresos Acumulados: 0.00 \u20ac Ocupado: True Prelavado a mano: True Secado a mano: True Encerado: True Fase: 0 - Inactivo ---------------------------------------- AVANZANDO FASE POR FASE: (COBRADO: 8.70 \u20ac) -> Fase actual: 1 - Cobrando -> Fase actual: 2 - Haciendo prelavado a mano -> Fase actual: 3 - Ech\u00e1ndole agua -> Fase actual: 4 - Enjabonando -> Fase actual: 5 - Pasando rodillos -> Fase actual: 6 - Haciendo secado autom\u00e1tico -> Fase actual: 0 - Inactivo ---------------------------------------- Lavado completo. Estado final: ---------------------------------------- Ingresos Acumulados: 8.70 \u20ac Ocupado: False Prelavado a mano: False Secado a mano: False Encerado: False Fase: 0 - Inactivo ---------------------------------------- Ingresos acumulados: 8.70 \u20ac ---------------------------------------- ======================================================= EJEMPLO 2: Sin extras (Prelavado: N, Secado a mano: N, Encerado: N) --- INICIO: Prueba de Lavado con Opciones Personalizadas --- Opciones solicitadas: [Prelavado: False, Secado a mano: False, Encerado: False] Coche entra. Estado inicial: ---------------------------------------- Ingresos Acumulados: 8.70 \u20ac Ocupado: True Prelavado a mano: False Secado a mano: False Encerado: False Fase: 0 - Inactivo ---------------------------------------- AVANZANDO FASE POR FASE: (COBRADO: 5.00 \u20ac) -> Fase actual: 1 - Cobrando -> Fase actual: 3 - Ech\u00e1ndole agua -> Fase actual: 4 - Enjabonando -> Fase actual: 5 - Pasando rodillos -> Fase actual: 7 - Haciendo secado a mano -> Fase actual: 0 - Inactivo ---------------------------------------- Lavado completo. Estado final: ---------------------------------------- Ingresos Acumulados: 13.70 \u20ac Ocupado: False Prelavado a mano: False Secado a mano: False Encerado: False Fase: 0 - Inactivo ---------------------------------------- Ingresos acumulados: 13.70 \u20ac ---------------------------------------- ======================================================= EJEMPLO 3: ERROR (Encerado S, Secado a mano N) --- INICIO: Prueba de Lavado con Opciones Personalizadas --- Opciones solicitadas: [Prelavado: False, Secado a mano: False, Encerado: True] ERROR DE ARGUMENTO: No se puede encerar el coche sin secado a mano ======================================================= EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) Cell In[21], line 26 24 print(\"\\n=======================================================\") 25 print(\"EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N)\") ---> 26 ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False) TypeError: ejecutarSimulacion() missing 1 required positional argument: 'encerado'","title":"Main Lavadero Documentado"},{"location":"Main_app_documentado_Adrian/#bloque-1-importacion","text":"from lavadero import Lavadero: Importa la clase Lavadero definida en el archivo lavadero.py . Funci\u00f3n: Permite usar en este script todas las operaciones y atributos del lavadero. Nota: En Python, la importaci\u00f3n busca el archivo en el mismo directorio o en el PYTHONPATH . # main_app.py from lavadero import Lavadero","title":"Bloque 1: Importaci\u00f3n"},{"location":"Main_app_documentado_Adrian/#bloque-2-definicion-de-la-funcion-ejecutarsimulacion","text":"Prop\u00f3sito: Simular un ciclo de lavado con las opciones dadas. Par\u00e1metros: lavadero : instancia de la clase Lavadero. prelavado : booleano, indica si se solicita prelavado a mano. secado_mano : booleano, indica si se solicita secado a mano. encerado : booleano, indica si se solicita encerado. Flujo de ejecuci\u00f3n: Imprime las opciones seleccionadas. Llama a hacerLavado() para iniciar el ciclo. Imprime el estado inicial del lavadero. Avanza fase por fase en un bucle controlado por contador (m\u00e1x. 20 pasos). Imprime cada fase recorrida. Al finalizar, muestra el estado final y los ingresos acumulados. Manejo de excepciones: ValueError : si se intenta encerar sin secado a mano. RuntimeError : si se intenta iniciar un lavado estando ocupado. Exception : cualquier otro error inesperado. def ejecutarSimulacion(lavadero, prelavado, secado_mano, encerado): \"\"\" Simula el proceso de lavado para un veh\u00edculo con las opciones dadas. Ahora acepta una instancia de lavadero. \"\"\" print(\"--- INICIO: Prueba de Lavado con Opciones Personalizadas ---\") print(f\"Opciones solicitadas: [Prelavado: {prelavado}, Secado a mano: {secado_mano}, Encerado: {encerado}]\") try: lavadero.hacerLavado(prelavado, secado_mano, encerado) print(\"\\nCoche entra. Estado inicial:\") lavadero.imprimir_estado() print(\"\\nAVANZANDO FASE POR FASE:\") pasos = 0 while lavadero.ocupado and pasos < 20: lavadero.avanzarFase() print(f\"-> Fase actual: \", end=\"\") lavadero.imprimir_fase() print() pasos += 1 print(\"\\n----------------------------------------\") print(\"Lavado completo. Estado final:\") lavadero.imprimir_estado() print(f\"Ingresos acumulados: {lavadero.ingresos:.2f} \u20ac\") print(\"----------------------------------------\") except ValueError as e: # Captura la excepci\u00f3n de regla de negocio (Requisito 2) print(f\"ERROR DE ARGUMENTO: {e}\") except RuntimeError as e: # Captura la excepci\u00f3n de estado (Requisito 3) print(f\"ERROR DE ESTADO: {e}\") except Exception as e: print(f\"ERROR INESPERADO: {e}\")","title":"Bloque 2: Definici\u00f3n de la funci\u00f3n ejecutarSimulacion"},{"location":"Main_app_documentado_Adrian/#bloque-3-punto-de-entrada-main-con-ejemplos","text":"if name == \" main \": Garantiza que el bloque se ejecute solo si el archivo se ejecuta directamente, no cuando se importa como m\u00f3dulo. lavadero_global = Lavadero(): Se crea una \u00fanica instancia de Lavadero para acumular ingresos entre simulaciones. Ejemplos de ejecuci\u00f3n: Ejemplo 1: Prelavado + Secado a mano + Encerado \u2192 ingresos esperados 8.70 \u20ac. Ejemplo 2: Sin extras \u2192 ingresos esperados 5.00 \u20ac. Ejemplo 3: Encerado sin secado \u2192 debe lanzar ValueError . Ejemplo 4: Solo prelavado \u2192 ingresos esperados 6.50 \u20ac. Funci\u00f3n: Demostrar distintos casos de uso, validar reglas de negocio y mostrar acumulaci\u00f3n de ingresos. if __name__ == \"__main__\": lavadero_global = Lavadero() # Usamos una \u00fanica instancia para acumular ingresos # EJEMPLO 1: Lavado completo con prelavado, secado a mano, con encerado (Requisito 8 y 14) # Precio esperado: 5.00 + 1.50 + 1.00 + 1.20 = 8.70 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 1: Prelavado (S), Secado a mano (S), Encerado (S)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=True, encerado=True) # EJEMPLO 2: Lavado r\u00e1pido sin extras (Requisito 9) # Precio esperado: 5.00 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 2: Sin extras (Prelavado: N, Secado a mano: N, Encerado: N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=False) # EJEMPLO 3: Lavado con encerado, pero sin secado a mano (Debe lanzar ValueError - Requisito 2) print(\"\\n=======================================================\") print(\"EJEMPLO 3: ERROR (Encerado S, Secado a mano N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=True) # EJEMPLO 4: Lavado con prelavado a mano (Requisito 4 y 10) # Precio esperado: 5.00 + 1.50 = 6.50 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False) ======================================================= EJEMPLO 1: Prelavado (S), Secado a mano (S), Encerado (S) --- INICIO: Prueba de Lavado con Opciones Personalizadas --- Opciones solicitadas: [Prelavado: True, Secado a mano: True, Encerado: True] Coche entra. Estado inicial: ---------------------------------------- Ingresos Acumulados: 0.00 \u20ac Ocupado: True Prelavado a mano: True Secado a mano: True Encerado: True Fase: 0 - Inactivo ---------------------------------------- AVANZANDO FASE POR FASE: (COBRADO: 8.70 \u20ac) -> Fase actual: 1 - Cobrando -> Fase actual: 2 - Haciendo prelavado a mano -> Fase actual: 3 - Ech\u00e1ndole agua -> Fase actual: 4 - Enjabonando -> Fase actual: 5 - Pasando rodillos -> Fase actual: 6 - Haciendo secado autom\u00e1tico -> Fase actual: 0 - Inactivo ---------------------------------------- Lavado completo. Estado final: ---------------------------------------- Ingresos Acumulados: 8.70 \u20ac Ocupado: False Prelavado a mano: False Secado a mano: False Encerado: False Fase: 0 - Inactivo ---------------------------------------- Ingresos acumulados: 8.70 \u20ac ---------------------------------------- ======================================================= EJEMPLO 2: Sin extras (Prelavado: N, Secado a mano: N, Encerado: N) --- INICIO: Prueba de Lavado con Opciones Personalizadas --- Opciones solicitadas: [Prelavado: False, Secado a mano: False, Encerado: False] Coche entra. Estado inicial: ---------------------------------------- Ingresos Acumulados: 8.70 \u20ac Ocupado: True Prelavado a mano: False Secado a mano: False Encerado: False Fase: 0 - Inactivo ---------------------------------------- AVANZANDO FASE POR FASE: (COBRADO: 5.00 \u20ac) -> Fase actual: 1 - Cobrando -> Fase actual: 3 - Ech\u00e1ndole agua -> Fase actual: 4 - Enjabonando -> Fase actual: 5 - Pasando rodillos -> Fase actual: 7 - Haciendo secado a mano -> Fase actual: 0 - Inactivo ---------------------------------------- Lavado completo. Estado final: ---------------------------------------- Ingresos Acumulados: 13.70 \u20ac Ocupado: False Prelavado a mano: False Secado a mano: False Encerado: False Fase: 0 - Inactivo ---------------------------------------- Ingresos acumulados: 13.70 \u20ac ---------------------------------------- ======================================================= EJEMPLO 3: ERROR (Encerado S, Secado a mano N) --- INICIO: Prueba de Lavado con Opciones Personalizadas --- Opciones solicitadas: [Prelavado: False, Secado a mano: False, Encerado: True] ERROR DE ARGUMENTO: No se puede encerar el coche sin secado a mano ======================================================= EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) Cell In[21], line 26 24 print(\"\\n=======================================================\") 25 print(\"EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N)\") ---> 26 ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False) TypeError: ejecutarSimulacion() missing 1 required positional argument: 'encerado'","title":"Bloque 3: Punto de entrada (main) con ejemplos"},{"location":"Pruebas/","text":"Informe de Pruebas Unitarias \u2013 Lavadero 1. C\u00f3digo de pruebas def test1_estado_inicial_correcto(self): \"\"\"Test 1: Estado inicial debe ser inactivo, sin ingresos y sin opciones.\"\"\" self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) self.assertEqual(self.lavadero.ingresos, 0.0) self.assertFalse(self.lavadero.ocupado) def test2_excepcion_encerado_sin_secado(self): \"\"\"Test 2: Encerar sin secado a mano debe lanzar ValueError.\"\"\" with self.assertRaises(ValueError): self.lavadero.hacerLavado(False, False, True) def test3_excepcion_lavado_ocupado(self): \"\"\"Test 3: Iniciar un lavado mientras otro est\u00e1 en marcha debe lanzar RuntimeError.\"\"\" self.lavadero.hacerLavado(False, False, False) with self.assertRaises(RuntimeError): self.lavadero.hacerLavado(True, True, True) def test4_prelavado_ingresos_y_fases(self): \"\"\"Test 4 y 10: Prelavado a mano -> ingresos 6.50\u20ac, fases [0,1,2,3,4,5,6,0].\"\"\" fases = self.lavadero.ejecutar_y_obtener_fases(True, False, False) self.assertEqual(self.lavadero.ingresos, 6.50) self.assertEqual(fases, [0,1,2,3,4,5,6,0]) def test5_secado_ingresos_y_fases(self): \"\"\"Test 5 y 11: Secado a mano -> ingresos 6.00\u20ac, fases [0,1,3,4,5,7,0].\"\"\" fases = self.lavadero.ejecutar_y_obtener_fases(False, True, False) self.assertEqual(self.lavadero.ingresos, 6.00) self.assertEqual(fases, [0,1,3,4,5,7,0]) def test6_secado_y_encerado(self): \"\"\"Test 6 y 12: Secado + encerado -> ingresos 7.20\u20ac, fases [0,1,3,4,5,7,8,0].\"\"\" fases = self.lavadero.ejecutar_y_obtener_fases(False, True, True) self.assertEqual(self.lavadero.ingresos, 7.20) self.assertEqual(fases, [0,1,3,4,5,7,8,0]) def test7_prelavado_y_secado(self): \"\"\"Test 7 y 13: Prelavado + secado -> ingresos 7.50\u20ac, fases [0,1,2,3,4,5,7,0].\"\"\" fases = self.lavadero.ejecutar_y_obtener_fases(True, True, False) self.assertEqual(self.lavadero.ingresos, 7.50) self.assertEqual(fases, [0,1,2,3,4,5,7,0]) def test8_prelavado_secado_encerado(self): \"\"\"Test 8 y 14: Prelavado + secado + encerado -> ingresos 8.70\u20ac, fases [0,1,2,3,4,5,7,8,0].\"\"\" fases = self.lavadero.ejecutar_y_obtener_fases(True, True, True) self.assertEqual(self.lavadero.ingresos, 8.70) self.assertEqual(fases, [0,1,2,3,4,5,7,8,0]) def test9_sin_extras(self): \"\"\"Test 9: Lavado r\u00e1pido sin extras -> ingresos 5.00\u20ac, fases [0,1,3,4,5,6,0].\"\"\" fases = self.lavadero.ejecutar_y_obtener_fases(False, False, False) self.assertEqual(self.lavadero.ingresos, 5.00) self.assertEqual(fases, [0,1,3,4,5,6,0]) 2. Ejecuci\u00f3n inicial (c\u00f3digo err\u00f3neo) Resumen Test Resultado esperado Resultado obtenido Test 1 Estado inicial correcto OK Test 2 ValueError al encerar sin secado OK Test 3 RuntimeError al iniciar lavado ocupado OK Test 4\u20139 Secuencias de fases e ingresos correctos ERROR (AttributeError) 3. Correcci\u00f3n del m\u00e9todo ejecutar_y_obtener_fases M\u00e9todo con c\u00f3digo err\u00f3neo En la ejecuci\u00f3n inicial, varios tests daban ERROR debido a un fallo en la implementaci\u00f3n del m\u00e9todo ejecutar_y_obtener_fases . El error concreto era: AttributeError: 'Lavadero' object has no attribute 'lavadero' Esto ocurr\u00eda porque dentro del m\u00e9todo se llamaba a self.lavadero.hacerLavado(...) , pero la clase Lavadero no tiene ning\u00fan atributo llamado lavadero . \ud83d\udd27 Arreglo realizado Se reemplaz\u00f3 la llamada incorrecta self.lavadero.hacerLavado(...) por self.hacerLavado(...) . Se ajust\u00f3 tambi\u00e9n el acceso a las propiedades ( self.fase , self.ocupado ) para que usen directamente la instancia actual. \ud83d\udccc Resultado tras el cambio Los tests ya no lanzan ERROR por AttributeError . Ahora los tests se ejecutan y muestran FAIL en los casos donde la l\u00f3gica de precios y fases a\u00fan no coincide con lo esperado. Esto permite avanzar en la depuraci\u00f3n: primero corregimos la ejecuci\u00f3n del m\u00e9todo, y despu\u00e9s ajustaremos la l\u00f3gica de negocio (precios y fases). 4. Correcci\u00f3n del m\u00e9todo _cobrar Bloque de c\u00f3digo err\u00f3neo En la ejecuci\u00f3n tras corregir ejecutar_y_obtener_fases , varios tests pasaron de ERROR a FAIL . El fallo concreto estaba en los ingresos calculados : El test de secado a mano ( test5_secado_ingresos_y_fases ) esperaba 6.00 \u20ac , pero el resultado era 6.20 \u20ac . El test de secado + encerado ( test6_secado_y_encerado ) esperaba 7.20 \u20ac , pero el resultado era 7.00 \u20ac . Otros tests tambi\u00e9n mostraban diferencias en los ingresos acumulados. Esto ocurr\u00eda porque en el m\u00e9todo _cobrar los valores de los extras estaban mal asignados: - Secado a mano sumaba 1.20 \u20ac en lugar de 1.00 \u20ac. - Encerado sumaba 1.00 \u20ac en lugar de 1.20 \u20ac. \ud83d\udd27 Arreglo realizado Se corrigi\u00f3 el valor del secado a mano : ahora suma 1.00 \u20ac. Se corrigi\u00f3 el valor del encerado : ahora suma 1.20 \u20ac. Se mantuvo el precio base de 5.00 \u20ac y el prelavado a mano en 1.50 \u20ac. \ud83d\udccc Resultado tras el cambio Los tests de ingresos ( test5 , test6 , test7 , test8 , test9 ) ahora muestran los valores correctos. Los FAIL por diferencias de precio desaparecen. Los tests a\u00fan muestran FAIL en algunos casos de fases, lo que indica que el siguiente paso es corregir la l\u00f3gica de transici\u00f3n en avanzarFase . 5. Correcci\u00f3n de la transici\u00f3n en la fase de rodillos Bloque de c\u00f3digo err\u00f3neo Tras corregir los ingresos en _cobrar , varios tests segu\u00edan dando FAIL . El fallo concreto estaba en las secuencias de fases : El test de secado a mano ( test5_secado_ingresos_y_fases ) esperaba terminar en la fase 7 (Secado a mano) , pero el flujo terminaba en la fase 6 (Secado autom\u00e1tico) . El test de lavado sin extras ( test9_sin_extras ) esperaba terminar en la fase 6 (Secado autom\u00e1tico) , pero el flujo terminaba en la fase 7 (Secado a mano) . Esto ocurr\u00eda porque la condici\u00f3n en el bloque de rodillos estaba invertida : - Si secado_a_mano = True , el c\u00f3digo enviaba a fase 6 (autom\u00e1tico). - Si secado_a_mano = False , el c\u00f3digo enviaba a fase 7 (manual). \ud83d\udd27 Arreglo realizado Se corrigi\u00f3 la condici\u00f3n en el bloque elif self.__fase == self.FASE_RODILLOS : Si secado_a_mano = True \u2192 pasar a FASE_SECADO_MANO (7) . Si secado_a_mano = False \u2192 pasar a FASE_SECADO_AUTOMATICO (6) . \ud83d\udccc Resultado tras el cambio El test de secado a mano ( test5 ) ahora muestra la secuencia correcta: [0,1,3,4,5,7,0] . El test sin extras ( test9 ) ahora muestra la secuencia correcta: [0,1,3,4,5,6,0] . Los FAIL por rutas incorrectas desaparecen. Los tests con encerado a\u00fan fallan, lo que indica que el siguiente paso es corregir la transici\u00f3n desde la fase 7 hacia la fase 8 cuando se selecciona encerado. 6. Correcci\u00f3n de la transici\u00f3n desde la fase 7 (Secado a mano) hacia la fase 8 (Encerado) Bloque de c\u00f3digo err\u00f3neo Tras corregir la transici\u00f3n en la fase de rodillos, varios tests segu\u00edan dando FAIL . El fallo concreto estaba en los lavados que inclu\u00edan encerado junto al secado a mano : El test de secado + encerado ( test6_secado_y_encerado ) esperaba la secuencia [0,1,3,4,5,7,8,0] , pero el flujo terminaba en [0,1,3,4,5,7,0] . El test de prelavado + secado + encerado ( test8_prelavado_secado_encerado ) esperaba [0,1,2,3,4,5,7,8,0] , pero el flujo terminaba en [0,1,2,3,4,5,7,0] . Esto ocurr\u00eda porque el bloque de transici\u00f3n en la fase 7 llamaba directamente a terminar() , sin comprobar si hab\u00eda que pasar por la fase 8 (encerado). \ud83d\udd27 Arreglo realizado Se modific\u00f3 el bloque elif self.__fase == self.FASE_SECADO_MANO : Si encerado = True \u2192 pasar a FASE_ENCERADO (8) . Si encerado = False \u2192 llamar a terminar() . \ud83d\udccc Resultado tras el cambio El test de secado + encerado ( test6 ) ahora muestra la secuencia correcta: [0,1,3,4,5,7,8,0] . El test de prelavado + secado + encerado ( test8 ) ahora muestra la secuencia correcta: [0,1,2,3,4,5,7,8,0] . Los FAIL por rutas incompletas desaparecen. Con esta correcci\u00f3n, todos los tests de ingresos y fases pasan a OK . 7. Conclusi\u00f3n final Tras realizar todas las correcciones paso a paso \u2014desde la ejecuci\u00f3n del m\u00e9todo, los precios en _cobrar , hasta la l\u00f3gica de transici\u00f3n entre fases\u2014 se ha conseguido que todos los tests unitarios pasen correctamente . Esto demuestra que el sistema de lavado cumple con los 14 requisitos funcionales definidos, y que el comportamiento del programa es el esperado en todos los casos. \ud83d\udccc Resultado final Todos los tests pasan ( OK ). Ingresos calculados correctamente. Secuencias de fases completas y coherentes. Excepciones lanzadas correctamente en casos inv\u00e1lidos. Este resultado valida que el c\u00f3digo es funcional, reproducible y cumple con los criterios de calidad exigidos. Adem\u00e1s, el uso de pruebas unitarias permite detectar errores de forma autom\u00e1tica y documentar claramente el proceso de correcci\u00f3n.","title":"Informe de Pruebas Unitarias \u2013 Lavadero"},{"location":"Pruebas/#informe-de-pruebas-unitarias-lavadero","text":"","title":"Informe de Pruebas Unitarias \u2013 Lavadero"},{"location":"Pruebas/#1-codigo-de-pruebas","text":"def test1_estado_inicial_correcto(self): \"\"\"Test 1: Estado inicial debe ser inactivo, sin ingresos y sin opciones.\"\"\" self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) self.assertEqual(self.lavadero.ingresos, 0.0) self.assertFalse(self.lavadero.ocupado) def test2_excepcion_encerado_sin_secado(self): \"\"\"Test 2: Encerar sin secado a mano debe lanzar ValueError.\"\"\" with self.assertRaises(ValueError): self.lavadero.hacerLavado(False, False, True) def test3_excepcion_lavado_ocupado(self): \"\"\"Test 3: Iniciar un lavado mientras otro est\u00e1 en marcha debe lanzar RuntimeError.\"\"\" self.lavadero.hacerLavado(False, False, False) with self.assertRaises(RuntimeError): self.lavadero.hacerLavado(True, True, True) def test4_prelavado_ingresos_y_fases(self): \"\"\"Test 4 y 10: Prelavado a mano -> ingresos 6.50\u20ac, fases [0,1,2,3,4,5,6,0].\"\"\" fases = self.lavadero.ejecutar_y_obtener_fases(True, False, False) self.assertEqual(self.lavadero.ingresos, 6.50) self.assertEqual(fases, [0,1,2,3,4,5,6,0]) def test5_secado_ingresos_y_fases(self): \"\"\"Test 5 y 11: Secado a mano -> ingresos 6.00\u20ac, fases [0,1,3,4,5,7,0].\"\"\" fases = self.lavadero.ejecutar_y_obtener_fases(False, True, False) self.assertEqual(self.lavadero.ingresos, 6.00) self.assertEqual(fases, [0,1,3,4,5,7,0]) def test6_secado_y_encerado(self): \"\"\"Test 6 y 12: Secado + encerado -> ingresos 7.20\u20ac, fases [0,1,3,4,5,7,8,0].\"\"\" fases = self.lavadero.ejecutar_y_obtener_fases(False, True, True) self.assertEqual(self.lavadero.ingresos, 7.20) self.assertEqual(fases, [0,1,3,4,5,7,8,0]) def test7_prelavado_y_secado(self): \"\"\"Test 7 y 13: Prelavado + secado -> ingresos 7.50\u20ac, fases [0,1,2,3,4,5,7,0].\"\"\" fases = self.lavadero.ejecutar_y_obtener_fases(True, True, False) self.assertEqual(self.lavadero.ingresos, 7.50) self.assertEqual(fases, [0,1,2,3,4,5,7,0]) def test8_prelavado_secado_encerado(self): \"\"\"Test 8 y 14: Prelavado + secado + encerado -> ingresos 8.70\u20ac, fases [0,1,2,3,4,5,7,8,0].\"\"\" fases = self.lavadero.ejecutar_y_obtener_fases(True, True, True) self.assertEqual(self.lavadero.ingresos, 8.70) self.assertEqual(fases, [0,1,2,3,4,5,7,8,0]) def test9_sin_extras(self): \"\"\"Test 9: Lavado r\u00e1pido sin extras -> ingresos 5.00\u20ac, fases [0,1,3,4,5,6,0].\"\"\" fases = self.lavadero.ejecutar_y_obtener_fases(False, False, False) self.assertEqual(self.lavadero.ingresos, 5.00) self.assertEqual(fases, [0,1,3,4,5,6,0])","title":"1. C\u00f3digo de pruebas"},{"location":"Pruebas/#2-ejecucion-inicial-codigo-erroneo","text":"","title":"2. Ejecuci\u00f3n inicial (c\u00f3digo err\u00f3neo)"},{"location":"Pruebas/#resumen","text":"Test Resultado esperado Resultado obtenido Test 1 Estado inicial correcto OK Test 2 ValueError al encerar sin secado OK Test 3 RuntimeError al iniciar lavado ocupado OK Test 4\u20139 Secuencias de fases e ingresos correctos ERROR (AttributeError)","title":"Resumen"},{"location":"Pruebas/#3-correccion-del-metodo-ejecutar_y_obtener_fases","text":"M\u00e9todo con c\u00f3digo err\u00f3neo En la ejecuci\u00f3n inicial, varios tests daban ERROR debido a un fallo en la implementaci\u00f3n del m\u00e9todo ejecutar_y_obtener_fases . El error concreto era: AttributeError: 'Lavadero' object has no attribute 'lavadero' Esto ocurr\u00eda porque dentro del m\u00e9todo se llamaba a self.lavadero.hacerLavado(...) , pero la clase Lavadero no tiene ning\u00fan atributo llamado lavadero .","title":"3. Correcci\u00f3n del m\u00e9todo ejecutar_y_obtener_fases"},{"location":"Pruebas/#arreglo-realizado","text":"Se reemplaz\u00f3 la llamada incorrecta self.lavadero.hacerLavado(...) por self.hacerLavado(...) . Se ajust\u00f3 tambi\u00e9n el acceso a las propiedades ( self.fase , self.ocupado ) para que usen directamente la instancia actual.","title":"\ud83d\udd27 Arreglo realizado"},{"location":"Pruebas/#resultado-tras-el-cambio","text":"Los tests ya no lanzan ERROR por AttributeError . Ahora los tests se ejecutan y muestran FAIL en los casos donde la l\u00f3gica de precios y fases a\u00fan no coincide con lo esperado. Esto permite avanzar en la depuraci\u00f3n: primero corregimos la ejecuci\u00f3n del m\u00e9todo, y despu\u00e9s ajustaremos la l\u00f3gica de negocio (precios y fases).","title":"\ud83d\udccc Resultado tras el cambio"},{"location":"Pruebas/#4-correccion-del-metodo-_cobrar","text":"Bloque de c\u00f3digo err\u00f3neo En la ejecuci\u00f3n tras corregir ejecutar_y_obtener_fases , varios tests pasaron de ERROR a FAIL . El fallo concreto estaba en los ingresos calculados : El test de secado a mano ( test5_secado_ingresos_y_fases ) esperaba 6.00 \u20ac , pero el resultado era 6.20 \u20ac . El test de secado + encerado ( test6_secado_y_encerado ) esperaba 7.20 \u20ac , pero el resultado era 7.00 \u20ac . Otros tests tambi\u00e9n mostraban diferencias en los ingresos acumulados. Esto ocurr\u00eda porque en el m\u00e9todo _cobrar los valores de los extras estaban mal asignados: - Secado a mano sumaba 1.20 \u20ac en lugar de 1.00 \u20ac. - Encerado sumaba 1.00 \u20ac en lugar de 1.20 \u20ac.","title":"4. Correcci\u00f3n del m\u00e9todo _cobrar"},{"location":"Pruebas/#arreglo-realizado_1","text":"Se corrigi\u00f3 el valor del secado a mano : ahora suma 1.00 \u20ac. Se corrigi\u00f3 el valor del encerado : ahora suma 1.20 \u20ac. Se mantuvo el precio base de 5.00 \u20ac y el prelavado a mano en 1.50 \u20ac.","title":"\ud83d\udd27 Arreglo realizado"},{"location":"Pruebas/#resultado-tras-el-cambio_1","text":"Los tests de ingresos ( test5 , test6 , test7 , test8 , test9 ) ahora muestran los valores correctos. Los FAIL por diferencias de precio desaparecen. Los tests a\u00fan muestran FAIL en algunos casos de fases, lo que indica que el siguiente paso es corregir la l\u00f3gica de transici\u00f3n en avanzarFase .","title":"\ud83d\udccc Resultado tras el cambio"},{"location":"Pruebas/#5-correccion-de-la-transicion-en-la-fase-de-rodillos","text":"Bloque de c\u00f3digo err\u00f3neo Tras corregir los ingresos en _cobrar , varios tests segu\u00edan dando FAIL . El fallo concreto estaba en las secuencias de fases : El test de secado a mano ( test5_secado_ingresos_y_fases ) esperaba terminar en la fase 7 (Secado a mano) , pero el flujo terminaba en la fase 6 (Secado autom\u00e1tico) . El test de lavado sin extras ( test9_sin_extras ) esperaba terminar en la fase 6 (Secado autom\u00e1tico) , pero el flujo terminaba en la fase 7 (Secado a mano) . Esto ocurr\u00eda porque la condici\u00f3n en el bloque de rodillos estaba invertida : - Si secado_a_mano = True , el c\u00f3digo enviaba a fase 6 (autom\u00e1tico). - Si secado_a_mano = False , el c\u00f3digo enviaba a fase 7 (manual).","title":"5. Correcci\u00f3n de la transici\u00f3n en la fase de rodillos"},{"location":"Pruebas/#arreglo-realizado_2","text":"Se corrigi\u00f3 la condici\u00f3n en el bloque elif self.__fase == self.FASE_RODILLOS : Si secado_a_mano = True \u2192 pasar a FASE_SECADO_MANO (7) . Si secado_a_mano = False \u2192 pasar a FASE_SECADO_AUTOMATICO (6) .","title":"\ud83d\udd27 Arreglo realizado"},{"location":"Pruebas/#resultado-tras-el-cambio_2","text":"El test de secado a mano ( test5 ) ahora muestra la secuencia correcta: [0,1,3,4,5,7,0] . El test sin extras ( test9 ) ahora muestra la secuencia correcta: [0,1,3,4,5,6,0] . Los FAIL por rutas incorrectas desaparecen. Los tests con encerado a\u00fan fallan, lo que indica que el siguiente paso es corregir la transici\u00f3n desde la fase 7 hacia la fase 8 cuando se selecciona encerado.","title":"\ud83d\udccc Resultado tras el cambio"},{"location":"Pruebas/#6-correccion-de-la-transicion-desde-la-fase-7-secado-a-mano-hacia-la-fase-8-encerado","text":"Bloque de c\u00f3digo err\u00f3neo Tras corregir la transici\u00f3n en la fase de rodillos, varios tests segu\u00edan dando FAIL . El fallo concreto estaba en los lavados que inclu\u00edan encerado junto al secado a mano : El test de secado + encerado ( test6_secado_y_encerado ) esperaba la secuencia [0,1,3,4,5,7,8,0] , pero el flujo terminaba en [0,1,3,4,5,7,0] . El test de prelavado + secado + encerado ( test8_prelavado_secado_encerado ) esperaba [0,1,2,3,4,5,7,8,0] , pero el flujo terminaba en [0,1,2,3,4,5,7,0] . Esto ocurr\u00eda porque el bloque de transici\u00f3n en la fase 7 llamaba directamente a terminar() , sin comprobar si hab\u00eda que pasar por la fase 8 (encerado).","title":"6. Correcci\u00f3n de la transici\u00f3n desde la fase 7 (Secado a mano) hacia la fase 8 (Encerado)"},{"location":"Pruebas/#arreglo-realizado_3","text":"Se modific\u00f3 el bloque elif self.__fase == self.FASE_SECADO_MANO : Si encerado = True \u2192 pasar a FASE_ENCERADO (8) . Si encerado = False \u2192 llamar a terminar() .","title":"\ud83d\udd27 Arreglo realizado"},{"location":"Pruebas/#resultado-tras-el-cambio_3","text":"El test de secado + encerado ( test6 ) ahora muestra la secuencia correcta: [0,1,3,4,5,7,8,0] . El test de prelavado + secado + encerado ( test8 ) ahora muestra la secuencia correcta: [0,1,2,3,4,5,7,8,0] . Los FAIL por rutas incompletas desaparecen. Con esta correcci\u00f3n, todos los tests de ingresos y fases pasan a OK .","title":"\ud83d\udccc Resultado tras el cambio"},{"location":"Pruebas/#7-conclusion-final","text":"Tras realizar todas las correcciones paso a paso \u2014desde la ejecuci\u00f3n del m\u00e9todo, los precios en _cobrar , hasta la l\u00f3gica de transici\u00f3n entre fases\u2014 se ha conseguido que todos los tests unitarios pasen correctamente . Esto demuestra que el sistema de lavado cumple con los 14 requisitos funcionales definidos, y que el comportamiento del programa es el esperado en todos los casos.","title":"7. Conclusi\u00f3n final"},{"location":"Pruebas/#resultado-final","text":"Todos los tests pasan ( OK ). Ingresos calculados correctamente. Secuencias de fases completas y coherentes. Excepciones lanzadas correctamente en casos inv\u00e1lidos. Este resultado valida que el c\u00f3digo es funcional, reproducible y cumple con los criterios de calidad exigidos. Adem\u00e1s, el uso de pruebas unitarias permite detectar errores de forma autom\u00e1tica y documentar claramente el proceso de correcci\u00f3n.","title":"\ud83d\udccc Resultado final"},{"location":"Reflexion/","text":"Reflexi\u00f3n comparativa sobre la infraestructura de seguridad de los lenguajes En el punto 4 coment\u00e9 c\u00f3mo las caracter\u00edsticas propias de cada lenguaje influyen en la seguridad: algunos ayudan a evitar errores gracias a la gesti\u00f3n autom\u00e1tica de memoria o a su claridad de sintaxis. Si ampliamos la mirada hacia la infraestructura de seguridad , vemos que no solo importa el lenguaje en s\u00ed, sino tambi\u00e9n lo que lo rodea: - El entorno donde se ejecuta (por ejemplo, m\u00e1quinas virtuales o int\u00e9rpretes). - Las librer\u00edas y frameworks que ya incluyen pr\u00e1cticas seguras. - La comunidad y las actualizaciones que corrigen fallos r\u00e1pidamente. Conclusi\u00f3n La seguridad depende tanto del dise\u00f1o del lenguaje como de la infraestructura que lo acompa\u00f1a. Un buen lenguaje sin soporte adecuado puede ser inseguro, y al rev\u00e9s, una infraestructura s\u00f3lida puede reforzar la seguridad de un lenguaje sencillo. Al final, ambos aspectos se complementan para lograr programas m\u00e1s confiables.","title":"Reflexi\u00f3n comparativa sobre la infraestructura de seguridad de los lenguajes"},{"location":"Reflexion/#reflexion-comparativa-sobre-la-infraestructura-de-seguridad-de-los-lenguajes","text":"En el punto 4 coment\u00e9 c\u00f3mo las caracter\u00edsticas propias de cada lenguaje influyen en la seguridad: algunos ayudan a evitar errores gracias a la gesti\u00f3n autom\u00e1tica de memoria o a su claridad de sintaxis. Si ampliamos la mirada hacia la infraestructura de seguridad , vemos que no solo importa el lenguaje en s\u00ed, sino tambi\u00e9n lo que lo rodea: - El entorno donde se ejecuta (por ejemplo, m\u00e1quinas virtuales o int\u00e9rpretes). - Las librer\u00edas y frameworks que ya incluyen pr\u00e1cticas seguras. - La comunidad y las actualizaciones que corrigen fallos r\u00e1pidamente.","title":"Reflexi\u00f3n comparativa sobre la infraestructura de seguridad de los lenguajes"},{"location":"Reflexion/#conclusion","text":"La seguridad depende tanto del dise\u00f1o del lenguaje como de la infraestructura que lo acompa\u00f1a. Un buen lenguaje sin soporte adecuado puede ser inseguro, y al rev\u00e9s, una infraestructura s\u00f3lida puede reforzar la seguridad de un lenguaje sencillo. Al final, ambos aspectos se complementan para lograr programas m\u00e1s confiables.","title":"Conclusi\u00f3n"},{"location":"lavadero_documentado_Adrian/","text":"1. Encabezado y definici\u00f3n de clase Prop\u00f3sito del m\u00f3dulo: Modelar un t\u00fanel de lavado con estados, reglas de negocio y secuencias de fases. Definici\u00f3n de clase Lavadero: En Python, una clase agrupa datos (atributos) y comportamiento (m\u00e9todos) de un objeto. Docstring de clase: El texto entre triple comillas describe el objetivo y alcance del componente, \u00fatil para documentaci\u00f3n y ayuda integrada. Nota de fidelidad: Documentamos tal cual sin corregir incoherencias, se\u00f1alamos las observaciones cuando afectan al entendimiento. # lavadero.py class Lavadero: \"\"\" Simula el estado y las operaciones de un t\u00fanel de lavado de coches. Cumple con los requisitos de estado, avance de fase y reglas de negocio. \"\"\" 2. Constantes de fase Constantes de estado: Representan fases del proceso como enteros con nombres sem\u00e1nticos, evitando \u201cn\u00fameros m\u00e1gicos\u201d y mejorando la legibilidad. Ventaja: Cambios futuros en los valores no afectan el c\u00f3digo que usa los nombres. Listado de fases: 0 inactivo, 1 cobrando, 2 prelavado, 3 agua, 4 enjabonado, 5 rodillos, 6 secado autom\u00e1tico, 7 secado a mano, 8 encerado. FASE_INACTIVO = 0 FASE_COBRANDO = 1 FASE_PRELAVADO_MANO = 2 FASE_ECHANDO_AGUA = 3 FASE_ENJABONANDO = 4 FASE_RODILLOS = 5 FASE_SECADO_AUTOMATICO = 6 FASE_SECADO_MANO = 7 FASE_ENCERADO = 8 3. Constructor y estado inicial init : M\u00e9todo especial que se ejecuta al crear una instancia. Inicializa el estado interno. Atributos \u201cprivados\u201d: El doble guion bajo activa name mangling (convenci\u00f3n para desalentar acceso externo directo). Estado base: ingresos 0.0, fase 0 (inactivo), ocupado False, extras False. Llamada a terminar(): Refuerza el estado inicial estableciendo los mismos valores. Aunque redundante, asegura consistencia. def __init__(self): \"\"\" Constructor de la clase. Inicializa el lavadero. Cumple con el requisito 1. \"\"\" self.__ingresos = 0.0 self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False self.terminar() 4. Propiedades de solo lectura @property: Permite acceder a m\u00e9todos como si fueran atributos, ofreciendo encapsulaci\u00f3n sin exponer variables internas. Getters: Devuelven el estado actual de fase, ingresos, ocupado y las opciones de extras. Uso: obj.fase , obj.ingresos , etc., sin par\u00e9ntesis, manteniendo interfaz clara. @property def fase(self): return self.__fase @property def ingresos(self): return self.__ingresos @property def ocupado(self): return self.__ocupado @property def prelavado_a_mano(self): return self.__prelavado_a_mano @property def secado_a_mano(self): return self.__secado_a_mano @property def encerado(self): return self.__encerado 5. Reinicio de ciclo con terminar() Funci\u00f3n: Restablece el lavadero a estado inactivo, no ocupado y sin extras. Momento de uso: Se invoca al finalizar fases terminales y en el constructor. Efecto: Cierra el ciclo y deja el objeto listo para un nuevo lavado. def terminar(self): self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False 6. Inicio de lavado y validaciones de negocio hacerLavado(...) : Configura un nuevo ciclo con las opciones dadas. Validaciones: Si el lavadero est\u00e1 ocupado, se levanta RuntimeError (no se admite solapamiento de ciclos). Si se solicita encerado sin secado a mano, se levanta ValueError (combinaci\u00f3n no permitida). Configuraci\u00f3n: Define ocupado=True , resetea fase a inactivo y guarda las opciones. def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" Inicia un nuevo ciclo de lavado, validando reglas de negocio. :raises RuntimeError: Si el lavadero est\u00e1 ocupado (Requisito 3). :raises ValueError: Si se intenta encerar sin secado a mano (Requisito 2). \"\"\" if self.__ocupado: raise RuntimeError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") if not secado_a_mano and encerado: raise ValueError(\"No se puede encerar el coche sin secado a mano\") self.__fase = self.FASE_INACTIVO self.__ocupado = True self.__prelavado_a_mano = prelavado_a_mano self.__secado_a_mano = secado_a_mano self.__encerado = encerado 7. C\u00e1lculo y acumulaci\u00f3n de ingresos _cobrar() : M\u00e9todo interno (por convenci\u00f3n) que calcula el coste del lavado y lo suma a los ingresos acumulados. Tarifa: Base 5.00; extras: +1.50 (prelavado), +1.20 (secado a mano), +1.00 (encerado). Retorno: Devuelve el importe cobrado para imprimirlo al avanzar la primera fase. Nota: Los importes est\u00e1n definidos en c\u00f3digo; no est\u00e1n parametrizados externamente. def _cobrar(self): \"\"\" Calcula y a\u00f1ade los ingresos seg\u00fan las opciones seleccionadas (Requisitos 4-8). Precio base: 5.00\u20ac (Impl\u00edcito, 5.00\u20ac de base + 1.50\u20ac de prelavado + 1.00\u20ac de secado + 1.20\u20ac de encerado = 8.70\u20ac) \"\"\" coste_lavado = 5.00 if self.__prelavado_a_mano: coste_lavado += 1.50 if self.__secado_a_mano: coste_lavado += 1.20 if self.__encerado: coste_lavado += 1.00 self.__ingresos += coste_lavado return coste_lavado 8. Avance de fase y l\u00f3gica de transici\u00f3n avanzarFase() : Orquesta la progresi\u00f3n de fases seg\u00fan el estado y las opciones. Guard clause: Si no est\u00e1 ocupado, retorna sin cambios (evita operar fuera de ciclo). Cobro al inicio: De fase 0 (inactivo) a 1 (cobrando) se ejecuta _cobrar() y se imprime el importe. Ramas principales: 1 \u2192 2 si hay prelavado, en otro caso 1 \u2192 3. Secuencia 2 \u2192 3 \u2192 4 \u2192 5. En 5, decisi\u00f3n de secado: si secado_a_mano True, va a 6 (autom\u00e1tico); si False, va a 7 (mano). Observaci\u00f3n: sem\u00e1ntica invertida respecto al nombre del flag. Fases 6/7/8: Terminan el ciclo llamando a terminar() . La fase 8 (encerado) no se alcanza por transici\u00f3n en el c\u00f3digo actual. Error de fase: Si aparece un estado no contemplado, RuntimeError con mensaje explicativo. def avanzarFase(self): if not self.__ocupado: return if self.__fase == self.FASE_INACTIVO: coste_cobrado = self._cobrar() self.__fase = self.FASE_COBRANDO print(f\" (COBRADO: {coste_cobrado:.2f} \u20ac) \", end=\"\") elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO else: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_AUTOMATICO else: self.__fase = self.FASE_SECADO_MANO elif self.__fase == self.FASE_SECADO_AUTOMATICO: self.terminar() elif self.__fase == self.FASE_SECADO_MANO: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() else: raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}. El lavadero va a estallar...\") 9. Impresi\u00f3n de fase legible imprimir_fase() : Traduce la fase actual a un texto amigable usando un diccionario fases_map . print(..., end=\"\") : Evita salto de l\u00ednea, permitiendo concatenar mensajes de estado en la misma l\u00ednea. Fallback: Si la fase no est\u00e1 mapeada, imprime un mensaje con el n\u00famero de fase y \u201cestado no v\u00e1lido\u201d. def imprimir_fase(self): fases_map = { self.FASE_INACTIVO: \"0 - Inactivo\", self.FASE_COBRANDO: \"1 - Cobrando\", self.FASE_PRELAVADO_MANO: \"2 - Haciendo prelavado a mano\", self.FASE_ECHANDO_AGUA: \"3 - Ech\u00e1ndole agua\", self.FASE_ENJABONANDO: \"4 - Enjabonando\", self.FASE_RODILLOS: \"5 - Pasando rodillos\", self.FASE_SECADO_AUTOMATICO: \"6 - Haciendo secado autom\u00e1tico\", self.FASE_SECADO_MANO: \"7 - Haciendo secado a mano\", self.FASE_ENCERADO: \"8 - Encerando a mano\", } print(fases_map.get(self.__fase, f\"{self.__fase} - En estado no v\u00e1lido\"), end=\"\") 10. Impresi\u00f3n de estado completo imprimir_estado() : Presenta un resumen del estado actual: ingresos acumulados, si est\u00e1 ocupado, opciones seleccionadas y fase. Formato: Usa separadores y formatea ingresos con dos decimales ( {self.ingresos:.2f} ). Composici\u00f3n: Llama a imprimir_fase() para no duplicar l\u00f3gica de texto de fase. def imprimir_estado(self): print(\"----------------------------------------\") print(f\"Ingresos Acumulados: {self.ingresos:.2f} \u20ac\") print(f\"Ocupado: {self.ocupado}\") print(f\"Prelavado a mano: {self.prelavado_a_mano}\") print(f\"Secado a mano: {self.secado_a_mano}\") print(f\"Encerado: {self.encerado}\") print(\"Fase: \", end=\"\") self.imprimir_fase() print(\"\\n----------------------------------------\") 11. M\u00e9todo auxiliar para pruebas unitarias (no funcional) Objetivo declarado: Ejecutar un ciclo completo devolviendo la lista de fases visitadas. Inconsistencia clave: Usa self.lavadero (atributo inexistente en la clase). Cualquier llamada lanzar\u00eda AttributeError . Estructura prevista: Parecer\u00eda querer contener una instancia interna o pasarla como par\u00e1metro; tal como est\u00e1, no debe usarse. L\u00edmite de seguridad: Comprueba que no se excedan 15 pasos para evitar bucles infinitos, buena pr\u00e1ctica en simulaciones. Conclusi\u00f3n: M\u00e9todo \u00fatil conceptualmente, pero incorrecto en la implementaci\u00f3n actual. # Esta funci\u00f3n es \u00fatil para pruebas unitarias, no es parte del lavadero real # nos crea un array con las fases visitadas en un ciclo completo def ejecutar_y_obtener_fases(self, prelavado, secado, encerado): \"\"\"Ejecuta un ciclo completo y devuelve la lista de fases visitadas.\"\"\" self.lavadero.hacerLavado(prelavado, secado, encerado) fases_visitadas = [self.lavadero.fase] while self.lavadero.ocupado: # Usamos un l\u00edmite de pasos para evitar bucles infinitos en caso de error if len(fases_visitadas) > 15: raise Exception(\"Bucle infinito detectado en la simulaci\u00f3n de fases.\") self.lavadero.avanzarFase() fases_visitadas.append(self.lavadero.fase) return fases_visitadas","title":"Lavadero Documentado"},{"location":"lavadero_documentado_Adrian/#1-encabezado-y-definicion-de-clase","text":"Prop\u00f3sito del m\u00f3dulo: Modelar un t\u00fanel de lavado con estados, reglas de negocio y secuencias de fases. Definici\u00f3n de clase Lavadero: En Python, una clase agrupa datos (atributos) y comportamiento (m\u00e9todos) de un objeto. Docstring de clase: El texto entre triple comillas describe el objetivo y alcance del componente, \u00fatil para documentaci\u00f3n y ayuda integrada. Nota de fidelidad: Documentamos tal cual sin corregir incoherencias, se\u00f1alamos las observaciones cuando afectan al entendimiento. # lavadero.py class Lavadero: \"\"\" Simula el estado y las operaciones de un t\u00fanel de lavado de coches. Cumple con los requisitos de estado, avance de fase y reglas de negocio. \"\"\"","title":"1. Encabezado y definici\u00f3n de clase"},{"location":"lavadero_documentado_Adrian/#2-constantes-de-fase","text":"Constantes de estado: Representan fases del proceso como enteros con nombres sem\u00e1nticos, evitando \u201cn\u00fameros m\u00e1gicos\u201d y mejorando la legibilidad. Ventaja: Cambios futuros en los valores no afectan el c\u00f3digo que usa los nombres. Listado de fases: 0 inactivo, 1 cobrando, 2 prelavado, 3 agua, 4 enjabonado, 5 rodillos, 6 secado autom\u00e1tico, 7 secado a mano, 8 encerado. FASE_INACTIVO = 0 FASE_COBRANDO = 1 FASE_PRELAVADO_MANO = 2 FASE_ECHANDO_AGUA = 3 FASE_ENJABONANDO = 4 FASE_RODILLOS = 5 FASE_SECADO_AUTOMATICO = 6 FASE_SECADO_MANO = 7 FASE_ENCERADO = 8","title":"2. Constantes de fase"},{"location":"lavadero_documentado_Adrian/#3-constructor-y-estado-inicial","text":"init : M\u00e9todo especial que se ejecuta al crear una instancia. Inicializa el estado interno. Atributos \u201cprivados\u201d: El doble guion bajo activa name mangling (convenci\u00f3n para desalentar acceso externo directo). Estado base: ingresos 0.0, fase 0 (inactivo), ocupado False, extras False. Llamada a terminar(): Refuerza el estado inicial estableciendo los mismos valores. Aunque redundante, asegura consistencia. def __init__(self): \"\"\" Constructor de la clase. Inicializa el lavadero. Cumple con el requisito 1. \"\"\" self.__ingresos = 0.0 self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False self.terminar()","title":"3. Constructor y estado inicial"},{"location":"lavadero_documentado_Adrian/#4-propiedades-de-solo-lectura","text":"@property: Permite acceder a m\u00e9todos como si fueran atributos, ofreciendo encapsulaci\u00f3n sin exponer variables internas. Getters: Devuelven el estado actual de fase, ingresos, ocupado y las opciones de extras. Uso: obj.fase , obj.ingresos , etc., sin par\u00e9ntesis, manteniendo interfaz clara. @property def fase(self): return self.__fase @property def ingresos(self): return self.__ingresos @property def ocupado(self): return self.__ocupado @property def prelavado_a_mano(self): return self.__prelavado_a_mano @property def secado_a_mano(self): return self.__secado_a_mano @property def encerado(self): return self.__encerado","title":"4. Propiedades de solo lectura"},{"location":"lavadero_documentado_Adrian/#5-reinicio-de-ciclo-con-terminar","text":"Funci\u00f3n: Restablece el lavadero a estado inactivo, no ocupado y sin extras. Momento de uso: Se invoca al finalizar fases terminales y en el constructor. Efecto: Cierra el ciclo y deja el objeto listo para un nuevo lavado. def terminar(self): self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False","title":"5. Reinicio de ciclo con terminar()"},{"location":"lavadero_documentado_Adrian/#6-inicio-de-lavado-y-validaciones-de-negocio","text":"hacerLavado(...) : Configura un nuevo ciclo con las opciones dadas. Validaciones: Si el lavadero est\u00e1 ocupado, se levanta RuntimeError (no se admite solapamiento de ciclos). Si se solicita encerado sin secado a mano, se levanta ValueError (combinaci\u00f3n no permitida). Configuraci\u00f3n: Define ocupado=True , resetea fase a inactivo y guarda las opciones. def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" Inicia un nuevo ciclo de lavado, validando reglas de negocio. :raises RuntimeError: Si el lavadero est\u00e1 ocupado (Requisito 3). :raises ValueError: Si se intenta encerar sin secado a mano (Requisito 2). \"\"\" if self.__ocupado: raise RuntimeError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") if not secado_a_mano and encerado: raise ValueError(\"No se puede encerar el coche sin secado a mano\") self.__fase = self.FASE_INACTIVO self.__ocupado = True self.__prelavado_a_mano = prelavado_a_mano self.__secado_a_mano = secado_a_mano self.__encerado = encerado","title":"6. Inicio de lavado y validaciones de negocio"},{"location":"lavadero_documentado_Adrian/#7-calculo-y-acumulacion-de-ingresos","text":"_cobrar() : M\u00e9todo interno (por convenci\u00f3n) que calcula el coste del lavado y lo suma a los ingresos acumulados. Tarifa: Base 5.00; extras: +1.50 (prelavado), +1.20 (secado a mano), +1.00 (encerado). Retorno: Devuelve el importe cobrado para imprimirlo al avanzar la primera fase. Nota: Los importes est\u00e1n definidos en c\u00f3digo; no est\u00e1n parametrizados externamente. def _cobrar(self): \"\"\" Calcula y a\u00f1ade los ingresos seg\u00fan las opciones seleccionadas (Requisitos 4-8). Precio base: 5.00\u20ac (Impl\u00edcito, 5.00\u20ac de base + 1.50\u20ac de prelavado + 1.00\u20ac de secado + 1.20\u20ac de encerado = 8.70\u20ac) \"\"\" coste_lavado = 5.00 if self.__prelavado_a_mano: coste_lavado += 1.50 if self.__secado_a_mano: coste_lavado += 1.20 if self.__encerado: coste_lavado += 1.00 self.__ingresos += coste_lavado return coste_lavado","title":"7. C\u00e1lculo y acumulaci\u00f3n de ingresos"},{"location":"lavadero_documentado_Adrian/#8-avance-de-fase-y-logica-de-transicion","text":"avanzarFase() : Orquesta la progresi\u00f3n de fases seg\u00fan el estado y las opciones. Guard clause: Si no est\u00e1 ocupado, retorna sin cambios (evita operar fuera de ciclo). Cobro al inicio: De fase 0 (inactivo) a 1 (cobrando) se ejecuta _cobrar() y se imprime el importe. Ramas principales: 1 \u2192 2 si hay prelavado, en otro caso 1 \u2192 3. Secuencia 2 \u2192 3 \u2192 4 \u2192 5. En 5, decisi\u00f3n de secado: si secado_a_mano True, va a 6 (autom\u00e1tico); si False, va a 7 (mano). Observaci\u00f3n: sem\u00e1ntica invertida respecto al nombre del flag. Fases 6/7/8: Terminan el ciclo llamando a terminar() . La fase 8 (encerado) no se alcanza por transici\u00f3n en el c\u00f3digo actual. Error de fase: Si aparece un estado no contemplado, RuntimeError con mensaje explicativo. def avanzarFase(self): if not self.__ocupado: return if self.__fase == self.FASE_INACTIVO: coste_cobrado = self._cobrar() self.__fase = self.FASE_COBRANDO print(f\" (COBRADO: {coste_cobrado:.2f} \u20ac) \", end=\"\") elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO else: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_AUTOMATICO else: self.__fase = self.FASE_SECADO_MANO elif self.__fase == self.FASE_SECADO_AUTOMATICO: self.terminar() elif self.__fase == self.FASE_SECADO_MANO: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() else: raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}. El lavadero va a estallar...\")","title":"8. Avance de fase y l\u00f3gica de transici\u00f3n"},{"location":"lavadero_documentado_Adrian/#9-impresion-de-fase-legible","text":"imprimir_fase() : Traduce la fase actual a un texto amigable usando un diccionario fases_map . print(..., end=\"\") : Evita salto de l\u00ednea, permitiendo concatenar mensajes de estado en la misma l\u00ednea. Fallback: Si la fase no est\u00e1 mapeada, imprime un mensaje con el n\u00famero de fase y \u201cestado no v\u00e1lido\u201d. def imprimir_fase(self): fases_map = { self.FASE_INACTIVO: \"0 - Inactivo\", self.FASE_COBRANDO: \"1 - Cobrando\", self.FASE_PRELAVADO_MANO: \"2 - Haciendo prelavado a mano\", self.FASE_ECHANDO_AGUA: \"3 - Ech\u00e1ndole agua\", self.FASE_ENJABONANDO: \"4 - Enjabonando\", self.FASE_RODILLOS: \"5 - Pasando rodillos\", self.FASE_SECADO_AUTOMATICO: \"6 - Haciendo secado autom\u00e1tico\", self.FASE_SECADO_MANO: \"7 - Haciendo secado a mano\", self.FASE_ENCERADO: \"8 - Encerando a mano\", } print(fases_map.get(self.__fase, f\"{self.__fase} - En estado no v\u00e1lido\"), end=\"\")","title":"9. Impresi\u00f3n de fase legible"},{"location":"lavadero_documentado_Adrian/#10-impresion-de-estado-completo","text":"imprimir_estado() : Presenta un resumen del estado actual: ingresos acumulados, si est\u00e1 ocupado, opciones seleccionadas y fase. Formato: Usa separadores y formatea ingresos con dos decimales ( {self.ingresos:.2f} ). Composici\u00f3n: Llama a imprimir_fase() para no duplicar l\u00f3gica de texto de fase. def imprimir_estado(self): print(\"----------------------------------------\") print(f\"Ingresos Acumulados: {self.ingresos:.2f} \u20ac\") print(f\"Ocupado: {self.ocupado}\") print(f\"Prelavado a mano: {self.prelavado_a_mano}\") print(f\"Secado a mano: {self.secado_a_mano}\") print(f\"Encerado: {self.encerado}\") print(\"Fase: \", end=\"\") self.imprimir_fase() print(\"\\n----------------------------------------\")","title":"10. Impresi\u00f3n de estado completo"},{"location":"lavadero_documentado_Adrian/#11-metodo-auxiliar-para-pruebas-unitarias-no-funcional","text":"Objetivo declarado: Ejecutar un ciclo completo devolviendo la lista de fases visitadas. Inconsistencia clave: Usa self.lavadero (atributo inexistente en la clase). Cualquier llamada lanzar\u00eda AttributeError . Estructura prevista: Parecer\u00eda querer contener una instancia interna o pasarla como par\u00e1metro; tal como est\u00e1, no debe usarse. L\u00edmite de seguridad: Comprueba que no se excedan 15 pasos para evitar bucles infinitos, buena pr\u00e1ctica en simulaciones. Conclusi\u00f3n: M\u00e9todo \u00fatil conceptualmente, pero incorrecto en la implementaci\u00f3n actual. # Esta funci\u00f3n es \u00fatil para pruebas unitarias, no es parte del lavadero real # nos crea un array con las fases visitadas en un ciclo completo def ejecutar_y_obtener_fases(self, prelavado, secado, encerado): \"\"\"Ejecuta un ciclo completo y devuelve la lista de fases visitadas.\"\"\" self.lavadero.hacerLavado(prelavado, secado, encerado) fases_visitadas = [self.lavadero.fase] while self.lavadero.ocupado: # Usamos un l\u00edmite de pasos para evitar bucles infinitos en caso de error if len(fases_visitadas) > 15: raise Exception(\"Bucle infinito detectado en la simulaci\u00f3n de fases.\") self.lavadero.avanzarFase() fases_visitadas.append(self.lavadero.fase) return fases_visitadas","title":"11. M\u00e9todo auxiliar para pruebas unitarias (no funcional)"}]}